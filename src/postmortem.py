"""
Post-Mortem Generator - Automatically creates incident post-mortems.

Features:
- Template-based generation (Jinja2)
- Timeline extraction
- Action item suggestions
- Blameless format
"""

import json
import logging
from datetime import datetime
from typing import Any, Optional

logger = logging.getLogger(__name__)


class PostMortemGenerator:
    """Generates post-mortem documents from incident data."""

    DEFAULT_TEMPLATE = '''# Post-Mortem: {title}

**Date**: {date}  
**Severity**: {severity}  
**Duration**: {duration}  
**Author**: Auto-generated by Incident Copilot  

---

## Summary

{summary}

## Impact

- **Services Affected**: {affected_services}
- **Users Impacted**: {users_impacted}
- **Revenue Impact**: {revenue_impact}

## Timeline (All times UTC)

| Time | Event |
|------|-------|
{timeline}

## Root Cause Analysis

{root_cause}

### Evidence

{evidence}

## Resolution

{resolution}

## What Went Well

- Incident was detected automatically by monitoring
- Response team was mobilized quickly
- AI-assisted analysis helped identify root cause faster

## What Went Wrong

- {what_went_wrong}

## Action Items

| Action | Owner | Due Date | Priority |
|--------|-------|----------|----------|
{action_items}

## Lessons Learned

{lessons_learned}

## Metrics

- **Time to Detection (TTD)**: {ttd}
- **Time to Mitigation (TTM)**: {ttm}  
- **Time to Resolution (TTR)**: {ttr}
- **Mean Time to Resolution (MTTR)**: {mttr}

---

*This post-mortem was automatically generated by [Incident Copilot](https://github.com/tommieseals/incident-copilot)*
'''

    def __init__(self, config: dict):
        """Initialize post-mortem generator."""
        self.config = config
        self.template_path = config.get("template_path")
        
        if self.template_path:
            try:
                with open(self.template_path) as f:
                    self.template = f.read()
            except FileNotFoundError:
                logger.warning(f"Template not found at {self.template_path}, using default")
                self.template = self.DEFAULT_TEMPLATE
        else:
            self.template = self.DEFAULT_TEMPLATE

    async def generate(self, incident: Any) -> str:
        """Generate a post-mortem document for the incident."""
        # Extract data from incident
        data = self._extract_incident_data(incident)
        
        # Fill template
        try:
            postmortem = self.template.format(**data)
        except KeyError as e:
            logger.warning(f"Missing template variable: {e}")
            postmortem = self._generate_fallback(incident, data)
        
        logger.info(f"Generated post-mortem for incident {incident.id}")
        return postmortem

    def _extract_incident_data(self, incident: Any) -> dict:
        """Extract and format data from incident for template."""
        # Calculate duration
        if hasattr(incident, "resolved_at") and incident.resolved_at:
            duration = incident.resolved_at - incident.triggered_at
            duration_str = self._format_duration(duration.total_seconds())
            mttr = duration_str
        else:
            duration_str = "Ongoing"
            mttr = "N/A"
        
        # Extract timeline from analysis
        timeline_entries = []
        if hasattr(incident, "analysis") and incident.analysis:
            analysis = incident.analysis
            for event in analysis.get("timeline", []):
                time = event.get("time", "??:??")
                desc = event.get("event", "Unknown event")
                timeline_entries.append(f"| {time} | {desc} |")
        
        if not timeline_entries:
            triggered = incident.triggered_at.strftime("%H:%M:%S") if hasattr(incident.triggered_at, "strftime") else str(incident.triggered_at)
            timeline_entries = [
                f"| {triggered} | Incident triggered |",
                "| -- | Investigation started |",
                "| -- | Root cause identified |",
            ]
            if hasattr(incident, "resolved_at") and incident.resolved_at:
                resolved = incident.resolved_at.strftime("%H:%M:%S")
                timeline_entries.append(f"| {resolved} | Incident resolved |")
        
        # Extract evidence
        evidence_items = []
        if hasattr(incident, "analysis") and incident.analysis:
            for ev in incident.analysis.get("evidence", [])[:5]:
                evidence_items.append(f"- {ev}")
        
        if not evidence_items:
            evidence_items = ["- See attached logs for details"]
        
        # Generate action items
        action_items = self._generate_action_items(incident)
        
        # Extract root cause
        root_cause = "Under investigation"
        if hasattr(incident, "analysis") and incident.analysis:
            root_cause = incident.analysis.get("root_cause", root_cause)
        
        # Format affected components
        affected = []
        if hasattr(incident, "analysis") and incident.analysis:
            affected = incident.analysis.get("affected_components", [])
        if not affected and hasattr(incident, "labels"):
            affected = [incident.labels.get("service", "Unknown")]
        
        return {
            "title": incident.title,
            "date": datetime.utcnow().strftime("%Y-%m-%d"),
            "severity": incident.severity.value if hasattr(incident.severity, "value") else str(incident.severity),
            "duration": duration_str,
            "summary": f"An incident was detected: {incident.description or incident.title}",
            "affected_services": ", ".join(affected) if affected else "See analysis",
            "users_impacted": "TBD - Pending impact analysis",
            "revenue_impact": "TBD - Pending business impact assessment",
            "timeline": "\n".join(timeline_entries),
            "root_cause": root_cause,
            "evidence": "\n".join(evidence_items),
            "resolution": self._format_resolution(incident),
            "what_went_wrong": "TBD - Pending retrospective",
            "action_items": "\n".join(action_items),
            "lessons_learned": "TBD - To be discussed in retrospective meeting",
            "ttd": "< 1 minute (automated detection)",
            "ttm": "TBD",
            "ttr": duration_str,
            "mttr": mttr,
        }

    def _format_duration(self, seconds: float) -> str:
        """Format duration in human-readable format."""
        if seconds < 60:
            return f"{int(seconds)} seconds"
        elif seconds < 3600:
            minutes = int(seconds // 60)
            secs = int(seconds % 60)
            return f"{minutes}m {secs}s"
        else:
            hours = int(seconds // 3600)
            minutes = int((seconds % 3600) // 60)
            return f"{hours}h {minutes}m"

    def _format_resolution(self, incident: Any) -> str:
        """Format resolution steps from suggested fixes."""
        if not hasattr(incident, "suggested_fixes") or not incident.suggested_fixes:
            return "Resolution steps were applied manually."
        
        steps = ["The following remediation steps were taken:\n"]
        for i, fix in enumerate(incident.suggested_fixes[:3], 1):
            title = fix.get("title", "Unknown fix")
            steps.append(f"{i}. **{title}**")
            for cmd in fix.get("commands", [])[:2]:
                if not cmd.startswith("#"):
                    steps.append(f"   ```\n   {cmd}\n   ```")
        
        return "\n".join(steps)

    def _generate_action_items(self, incident: Any) -> list[str]:
        """Generate action items based on incident."""
        items = [
            "| Review and finalize this post-mortem | On-call engineer | +3 days | High |",
            "| Implement monitoring improvements | SRE team | +1 week | Medium |",
            "| Update runbooks with learnings | On-call engineer | +1 week | Medium |",
        ]
        
        # Add specific items from analysis
        if hasattr(incident, "analysis") and incident.analysis:
            root_cause = incident.analysis.get("root_cause", "").lower()
            
            if "memory" in root_cause or "oom" in root_cause:
                items.insert(0, "| Review memory limits for affected services | Dev team | +1 week | High |")
            
            if "connection" in root_cause or "pool" in root_cause:
                items.insert(0, "| Audit database connection management | Dev team | +2 weeks | High |")
            
            if "timeout" in root_cause:
                items.insert(0, "| Review timeout configurations | Dev team | +1 week | Medium |")
        
        return items[:5]  # Limit to 5 action items

    def _generate_fallback(self, incident: Any, data: dict) -> str:
        """Generate a simpler fallback post-mortem."""
        return f'''# Post-Mortem: {data.get("title", "Unknown Incident")}

**Date**: {data.get("date", datetime.utcnow().strftime("%Y-%m-%d"))}
**Severity**: {data.get("severity", "Unknown")}

## Summary

{data.get("summary", "An incident occurred.")}

## Root Cause

{data.get("root_cause", "Under investigation")}

## Action Items

- Review this incident in team retrospective
- Update monitoring and alerting
- Document learnings in runbooks

---
*Auto-generated by Incident Copilot*
'''


if __name__ == "__main__":
    # Example usage
    import asyncio
    
    async def test():
        generator = PostMortemGenerator({})
        
        class MockIncident:
            id = "test-123"
            title = "High error rate on API"
            description = "500 errors spiked to 50%"
            severity = "high"
            source = "prometheus"
            triggered_at = datetime(2024, 1, 15, 10, 30, 0)
            resolved_at = datetime(2024, 1, 15, 11, 15, 0)
            labels = {"service": "api-gateway"}
            analysis = {
                "root_cause": "Database connection pool exhaustion",
                "evidence": ["Connection timeout errors in logs", "Pool size at max"],
                "timeline": [
                    {"time": "10:30:00", "event": "Alert triggered"},
                    {"time": "10:35:00", "event": "Investigation started"},
                ],
                "affected_components": ["api-gateway", "database"],
            }
            suggested_fixes = [
                {"title": "Restart pods", "commands": ["kubectl rollout restart deployment/api"]}
            ]
        
        postmortem = await generator.generate(MockIncident())
        print(postmortem)
    
    asyncio.run(test())
